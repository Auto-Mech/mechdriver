if RUN_REACTIONS_QCHEM:
    for rct_names, prd_names in zip(RCT_NAMES_LST, PRD_NAMES_LST):
        # print the CHEMKIN reaction name for reference
        rxn_name = '='.join(['+'.join(rct_names), '+'.join(prd_names)])
        print()
        print("Reaction: {}".format(rxn_name))

        # determine inchis, charges, and multiplicities

        rct_smis = list(map(SMI_DCT.__getitem__, rct_names))
        prd_smis = list(map(SMI_DCT.__getitem__, prd_names))
        rct_ichs = list(map(automol.smiles.inchi, rct_smis))
        prd_ichs = list(map(automol.smiles.inchi, prd_smis))
        rct_chgs = list(map(CHG_DCT.__getitem__, rct_names))
        prd_chgs = list(map(CHG_DCT.__getitem__, prd_names))
        rct_muls = list(map(MUL_DCT.__getitem__, rct_names))
        prd_muls = list(map(MUL_DCT.__getitem__, prd_names))

        # determine the transition state multiplicity
        ts_mul = automol.mult.ts.low(rct_muls, prd_muls)
        ts_chg = sum(rct_chgs)
        print('ts_chg test:',ts_chg)
        ts_info = ('', ts_chg, ts_mul)

        # theory
        for opt_level_idx, _ in enumerate(RUN_OPT_LEVELS):
#        for prog, method, basis in RUN_OPT_LEVELS:
            prog = RUN_OPT_LEVELS[opt_level_idx][0]
            SCRIPT_STR, OPT_SCRIPT_STR, KWARGS, OPT_KWARGS = (
                moldr.util.run_qchem_par(prog))

            ts_orb_restr = moldr.util.orbital_restriction(
                ts_info, RUN_OPT_LEVELS[opt_level_idx])
            thy_level = RUN_OPT_LEVELS[opt_level_idx][1:3]
            thy_level.append(orb_restr)

#            ts_orb_restr = moldr.util.orbital_restriction(
#                ts_mul, RESTRICT_OPEN_SHELL)

            # check direction of reaction
            rxn_ichs = [rct_ichs, prd_ichs]
            rxn_chgs = [rct_chgs, prd_chgs]
            rxn_muls = [rct_muls, prd_muls]
#            rxn_info = zip(rxn_ichs, rxn_chgs, rxn_muls)
#            print('rxn_info test:', rxn_info)
            rxn_exo = moldr.util.reaction_energy(
                    SAVE_PREFIX, rxn_ichs, rxn_chgs, rxn_muls, RUN_OPT_LEVELS[opt_level_idx])
#                    SAVE_PREFIX, rxn_ichs, rxn_chgs, rxn_muls, thy_level)
#                SAVE_PREFIX, rxn_ichs, rxn_chgs, rxn_muls, method, basis,
#                RESTRICT_OPEN_SHELL)
            print(rxn_exo)
            if rxn_exo > 0:
                rct_ichs, prd_ichs = prd_ichs, rct_ichs
                rct_chgs, prd_chgs = prd_chgs, rct_chgs
                rct_muls, prd_muls = prd_muls, rct_muls
                print('ts search will be performed in reverse direction')

            # obtain geometries from a hierachy of (i) data directory and (ii)
            # previous species calculation
            rct_geos = []
            for ich, chg, mul in zip(rct_ichs, rct_chgs, rct_muls):
                rct_info = [ich, chg, mul]
#                orb_restr = moldr.util.orbital_restriction(
#                    rct_info, RUN_OPT_LEVELS[opt_level_idx])
#                rct_level = RUN_OPT_LEVELS[opt_level_idx][1:3]
#                rct_level.append(orb_restr)
#                print('geo test in rxn_qchem:', rct_info, rct_level, SAVE_PREFIX, GEOM_DCT)
                geo = moldr.util.reference_geometry(
                    rct_info, RUN_OPT_LEVELS[opt_level_idx], SAVE_PREFIX,
                    GEOM_DCT)
                rct_geos.append(geo)

            prd_geos = []
            for ich, chg, mul in zip(prd_ichs, prd_chgs, prd_muls):
                prd_info = [ich, chg, mul]
#                orb_restr = moldr.util.orbital_restriction(
#                    prd_info, RUN_OPT_LEVELS[opt_level_idx])
#                prd_level = RUN_OPT_LEVELS[opt_level_idx][1:3]
#                prd_level.append(orb_restr)
                geo = moldr.util.reference_geometry(
                    prd_info, RUN_OPT_LEVELS[opt_level_idx], SAVE_PREFIX,
                    GEOM_DCT)
                prd_geos.append(geo)

            # determine the transition state z-matrix
            # replace this with save values if they are available
            rct_zmas = list(map(automol.geom.zmatrix, rct_geos))
            prd_zmas = list(map(automol.geom.zmatrix, prd_geos))

            typ = None

            # # (migrations are not yet implemented)
            # ret = automol.zmatrix.ts.hydrogen_migration(rct_zmas, prd_zmas)
            # if ret and typ is None:
            #     typ = 'hydrogen migration'

            ret = automol.zmatrix.ts.beta_scission(rct_zmas, prd_zmas)
            if ret and typ is None:
                typ = 'beta scission'
                ts_zma, dist_name, tors_names = ret

            ret = automol.zmatrix.ts.addition(rct_zmas, prd_zmas)
            if ret and typ is None:
                typ = 'addition'
                ts_zma, dist_name, tors_names = ret

            # fix this later
            # ret = automol.zmatrix.ts.hydrogen_abstraction(rct_zmas, prd_zmas,
            #                                               sigma=True)
            ret = automol.zmatrix.ts.hydrogen_abstraction(rct_zmas, prd_zmas,
                                                          sigma=False)
            if ret and typ is None:
                typ = 'hydrogen abstraction'
                ts_zma, dist_name, tors_names = ret

            if typ is None:
                print("Failed to classify reaction.")
            else:
                print("Type: {}".format(typ))

                # determine the grid
                dist_coo, = automol.zmatrix.coordinates(ts_zma)[dist_name]
                syms = automol.zmatrix.symbols(ts_zma)
                bnd_len_key = tuple(sorted(map(syms.__getitem__, dist_coo)))

                bnd_len_dct = {
                    ('C', 'C'): 1.54 * ANG2BOHR,
                    ('C', 'H'): 1.09 * ANG2BOHR,
                    ('H', 'H'): 0.74 * ANG2BOHR,
                    ('N', 'N'): 1.45 * ANG2BOHR,
                    ('O', 'O'): 1.48 * ANG2BOHR,
                    ('C', 'N'): 1.47 * ANG2BOHR,
                    ('C', 'O'): 1.43 * ANG2BOHR,
                    ('H', 'O'): 1.20 * ANG2BOHR,
                    ('H', 'N'): 0.99 * ANG2BOHR,
                }

                if typ in ('beta scission', 'addition'):
                    rmin = 1.4 * ANG2BOHR
                    rmin = 2.8 * ANG2BOHR
                    if bnd_len_key in bnd_len_dct:
                        bnd_len = bnd_len_dct[bnd_len_key]
                        rmin = bnd_len + 0.2 * ANG2BOHR
                        rmax = bnd_len + 1.6 * ANG2BOHR
                elif typ == 'hydrogen abstraction':
                    rmin = 0.7 * ANG2BOHR
                    rmax = 2.2 * ANG2BOHR
                    if bnd_len_key in bnd_len_dct:
                        bnd_len = bnd_len_dct[bnd_len_key]
                        rmin = bnd_len
                        rmax = bnd_len + 1.0 * ANG2BOHR

                npoints = 8
                grid = numpy.linspace(rmin, rmax, npoints)

                # construct the filesystem
                rxn_ichs = [rct_ichs, prd_ichs]
                rxn_chgs = [rct_chgs, prd_chgs]
                rxn_muls = [rct_muls, prd_muls]

                # set up the filesystem
                is_rev = autofile.system.reaction_is_reversed(
                    rxn_ichs, rxn_chgs, rxn_muls)
                rxn_ichs, rxn_chgs, rxn_muls = autofile.system.sort_together(
                    rxn_ichs, rxn_chgs, rxn_muls)
                print(" - The reaction direction is {}"
                      .format('backward' if is_rev else 'forward'))

                ts_chg = 0
                for rct_chg in rct_chgs:
                    ts_chg += rct_chg
                ts_info = ['', ts_chg, ts_mul]

                rxn_run_fs = autofile.fs.reaction(RUN_PREFIX)
                rxn_run_fs.leaf.create([rxn_ichs, rxn_chgs, rxn_muls, ts_mul])
                rxn_run_path = rxn_run_fs.leaf.path(
                    [rxn_ichs, rxn_chgs, rxn_muls, ts_mul])

                rxn_ichs = tuple(map(tuple, rxn_ichs))
                rxn_chgs = tuple(map(tuple, rxn_chgs))
                rxn_muls = tuple(map(tuple, rxn_muls))
                print('rxn_save test0', rxn_ichs, rxn_chgs, rxn_muls, ts_mul)
                print(SAVE_PREFIX)
                rxn_save_fs = autofile.fs.reaction(SAVE_PREFIX)
                rxn_save_fs.leaf.create([rxn_ichs, rxn_chgs, rxn_muls, ts_mul])
                rxn_save_path = rxn_save_fs.leaf.path(
                    [rxn_ichs, rxn_chgs, rxn_muls, ts_mul])

                orb_restr = moldr.util.orbital_restriction(
                    ts_info, RUN_OPT_LEVELS[opt_level_idx])
                ref_level = RUN_OPT_LEVELS[opt_level_idx][1:3]
                ref_level.append(orb_restr)
                print('ref level test:', ref_level)

                thy_run_fs = autofile.fs.theory(rxn_run_path)
                thy_run_fs.leaf.create(ref_level)
                thy_run_path = thy_run_fs.leaf.path(
                    ref_level)

                thy_save_fs = autofile.fs.theory(rxn_save_path)
                thy_save_fs.leaf.create(ref_level)
                thy_save_path = thy_save_fs.leaf.path(ref_level)

                print('entering run_scan:')

                moldr.driver.run_scan(
                    zma=ts_zma,
                    species_info=ts_info,
                    theory_level=RUN_OPT_LEVELS[opt_level_idx],
                    grid_dct={dist_name: grid},
                    run_prefix=thy_run_path,
                    save_prefix=thy_save_path,
                    script_str=SCRIPT_STR,
                    overwrite=OVERWRITE,
                    update_guess=False,
                    reverse_sweep=False,
                    **OPT_KWARGS
                )

                moldr.driver.save_scan(
                    run_prefix=thy_run_path,
                    save_prefix=thy_save_path,
                    coo_names=[dist_name],
                )

                scn_save_fs = autofile.fs.scan(thy_save_path)
                locs_lst = [
                    locs for locs in scn_save_fs.leaf.existing([[dist_name]])
                    if scn_save_fs.leaf.file.energy.exists(locs)]
                print(locs_lst)
                enes = [scn_save_fs.leaf.file.energy.read(locs)
                        for locs in locs_lst]
                max_locs = locs_lst[enes.index(max(enes))]
                max_ene = max(enes)
                max_zma = scn_save_fs.leaf.file.zmatrix.read(max_locs)

                print('optimizing ts')
                # find saddlepoint from maximum on the grid opt scan
                print('thy_run_path in ts_opt:', thy_run_path)
                ts_run_fs = autofile.fs.ts(thy_run_path)
                ts_run_fs.trunk.create()
                ts_run_path = ts_run_fs.trunk.path()
                print('ts_run_path:', ts_run_path)
#                ts_run_path = ts_run_fs.trunk.path(ref_level)
#                print('ts_run_path:', ts_run_path)

                ts_save_fs = autofile.fs.ts(thy_save_path)
                ts_save_fs.trunk.create()
                ts_save_path = ts_save_fs.trunk.path()
                print('ts_save_path:', ts_save_path)
#                ts_save_fs.leaf.create()

#                cnf_run_fs = autofile.fs.conformer(ts_run_path)
#                cnf_run_fs.trunk.create()
#                cnf_save_fs = autofile.fs.conformer(ts_save_path)
#                cnf_save_fs.trunk.create()

#                cnf_locs_lst = cnf_save_fs.leaf.existing()
#                print('cnf_locs_lst:', cnf_locs_lst)
#                for locs in cnf_locs_lst:
#                    cnf_run_path = cnf_run_fs.leaf.path(locs)
#                    cnf_save_path = cnf_run_fs.leaf.path(locs)
#                    print(locs)

#                print('cnf_run_path:', cnf_run_path)
#                print('cnf_save_path:', cnf_save_path)
                moldr.driver.run_job(
                    job='optimization',
                    script_str=SCRIPT_STR,
                    prefix=ts_run_path,
                    geom=max_zma,
                    species_info=ts_info,
                    theory_level=RUN_OPT_LEVELS[opt_level_idx],
                    saddle=True,
                    overwrite=OVERWRITE,
                    **OPT_KWARGS,
                )
                opt_ret = moldr.driver.read_job(
                    job='optimization',
                    prefix=ts_run_path,
                )
                if opt_ret is not None:
                    inf_obj, inp_str, out_str = opt_ret
                    prog = inf_obj.prog
                    method = inf_obj.method
                    ene = elstruct.reader.energy(prog, method, out_str)
                    geo = elstruct.reader.opt_geometry(prog, out_str)
                    zma = elstruct.reader.opt_zmatrix(prog, out_str)

                    print(" - Saving...")
                    print(" - Save path: {}".format(ts_save_path))

#                   thy_save_fs.leaf.file.geometry_info.write(inf_obj)
#                   thy_save_fs.leaf.file.geometry_input.write(inp_str)
                    ts_save_fs.trunk.file.energy.write(ene)
                    ts_save_fs.trunk.file.geometry.write(geo)
                    ts_save_fs.trunk.file.zmatrix.write(zma)

#                    moldr.driver.run_job(
#                        job='hessian',
#                        script_str=SCRIPT_STR,
#                        prefix=thy_run_path,
#                        geom=geo,
#                        species_info=ts_info,
#                        theory_level=RUN_OPT_LEVELS[opt_level_idx],
#                        overwrite=OVERWRITE,
#                        **KWARGS,
#                    )
#                    hess_ret = moldr.driver.read_job(
#                        job='hessian',
#                        prefix=thy_run_path,
#                    )
#                    if hess_ret is not None:
#                        inf_obj, inp_str, out_str = hess_ret
#                        prog = inf_obj.prog
#                        method = inf_obj.method
#                        hess = elstruct.reader.hessian(prog, out_str)
#                        freqs = elstruct.util.harmonic_frequencies(geo, hess)
#
#                        print(" - Saving hessian...")
#                        print(" - Save path: {}".format(thy_save_path))
#
#                        thy_save_fs.leaf.file.hessian_info.write(inf_obj)
#                        thy_save_fs.leaf.file.hessian_input.write(inp_str)
#                        thy_save_fs.leaf.file.hessian.write(hess)
#                        thy_save_fs.leaf.file.harmonic_frequencies.write(freqs)

            if RUN_TS_CONF_SAMP:
                moldr.driver.conformer_sampling(
                    species_info=ts_info,
                    theory_level=RUN_OPT_LEVELS[opt_level_idx],
                    run_prefix=ts_run_path,
                    save_prefix=ts_save_path,
                    script_str=SCRIPT_STR,
                    overwrite=OVERWRITE,
                    saddle=True,
                    nsamp_par=NSAMP_CONF_PAR,
                    **OPT_KWARGS,
                )

                if RUN_TS_MIN_GRAD:
                    moldr.driver.run_minimum_energy_gradient(
                        species_info=ts_info,
                        theory_level=RUN_OPT_LEVELS[opt_level_idx],
                        run_prefix=ts_run_path,
                        save_prefix=ts_save_path,
                        script_str=SCRIPT_STR,
                        overwrite=OVERWRITE,
                        **KWARGS,
                    )

                if RUN_TS_MIN_HESS:
                    moldr.driver.run_minimum_energy_hessian(
                        species_info=ts_info,
                        theory_level=RUN_OPT_LEVELS[opt_level_idx],
                        run_prefix=ts_run_path,
                        save_prefix=ts_save_path,
                        script_str=SCRIPT_STR,
                        overwrite=OVERWRITE,
                        **KWARGS,
                    )

                if RUN_TS_MIN_VPT2:
                    moldr.driver.run_minimum_energy_vpt2(
                        species_info=ts_info,
                        theory_level=RUN_OPT_LEVELS[opt_level_idx],
                        run_prefix=ts_run_path,
                        save_prefix=ts_save_path,
                        script_str=SCRIPT_STR,
                        overwrite=OVERWRITE,
                        **KWARGS,
                    )

                if RUN_TS_TAU_SAMP:

                    moldr.driver.save_tau(
                        run_prefix=thy_run_path,
                        save_prefix=thy_save_path,
                    )

                    zma = ts_save_fs.trunk.file.zmatrix.read()
                    tors_ranges = automol.zmatrix.torsional_sampling_ranges(
                        zma, tors_names)
                    tors_range_dct = dict(zip(tors_names, tors_ranges))

                    moldr.driver.run_tau(
                        zma=zma,
                        species_info=ts_info,
                        theory_level=RUN_OPT_LEVELS[opt_level_idx],
                        nsamp=nsamp,
                        tors_range_dct=tors_range_dct,
                        run_prefix=thy_run_path,
                        save_prefix=thy_save_path,
                        script_str=SCRIPT_STR,
                        overwrite=OVERWRITE,
                        **OPT_KWARGS,
                    )
#                        saddle=True,
# used to have saddle=True in call, but this is not used. Probably a bug.

                    moldr.driver.save_tau(
                        run_prefix=thy_run_path,
                        save_prefix=thy_save_path,
                    )

                if RUN_TS_CONF_SCAN:
                    zma = ts_save_fs.trunk.file.zmatrix.read(thy_save_path)
                    val_dct = automol.zmatrix.values(zma)
                    tors_linspaces = automol.zmatrix.torsional_scan_linspaces(
                        zma, tors_names, SCAN_INCREMENT)
                    tors_grids = [
                        numpy.linspace(*linspace) + val_dct[name]
                        for name, linspace in zip(tors_name, tors_linspaces)]
                    for tors_name, tors_grid in zip(tors_names, tors_grids):
                        moldr.driver.run_scan(
                            zma=zma,
                            species_info=ts_info,
                            theory_level=RUN_OPT_LEVELS[opt_level_idx],
                            grid_dct={tors_name: tors_grid},
                            run_prefix=ts_run_path,
                            save_prefix=ts_save_path,
                            script_str=SCRIPT_STR,
                            overwrite=OVERWRITE,
                            **OPT_KWARGS,
                        )
#                            saddle=True,
# ??

                        moldr.driver.save_scan(
                            run_prefix=ts_run_path,
                            save_prefix=ts_save_path,
                            coo_names=[tors_name],
                        )
# AVC: debugged to here
                    hind_rot_dct = {}
                    scn_run_fs = autofile.fs.scan(ts_run_path)
                    scn_save_fs = autofile.fs.scan(ts_save_path)

                    min_ene = ts_save_fs.leaf.file.energy.read()
                    for tors_name in tors_names:
                        enes = [scn_save_fs.leaf.file.energy.read(locs)
                                for locs in scn_save_fs.leaf.existing()]
                        enes = numpy.subtract(enes, min_ene)
                        hind_rot_dct[tors_name] = enes*EH2KCAL

                    print('ts hindered rotor potential')
                    print(hind_rot_dct)

                if RUN_TS_KICKS_QCHEM:
                    ret = moldr.driver.read_job(
                        job=elstruct.Job.HESSIAN, prefix=ts_run_path)
                    if ret:
                        inf_obj, _, out_str = ret
                        prog = inf_obj.prog
                        hess = elstruct.reader.hessian(prog, out_str)
                        freqs = elstruct.util.harmonic_frequencies(geo, hess, project=True)
                        norm_coos = elstruct.util.normal_coordinates(geo, hess, project=True)
                        assert freqs[0] < -100

                        print('Kicking off from saddle in forward direction')
                        im_norm_coo = numpy.array(norm_coos)[:, 0]
                        disp_xyzs = numpy.reshape(im_norm_coo, (-1, 3))
                        dir_afs = autofile.fs.direction()
                        fwd_run_path = dir_afs.direction.dir.path(thy_run_path, [True])
                        dir_afs.direction.dir.create(thy_run_path, [True])
                        fwd_save_path = dir_afs.direction.dir.path(thy_save_path, [True])
                        dir_afs.direction.dir.create(thy_save_path, [True])
                        print(automol.geom.string(geo))
                        print(disp_xyzs)
                        moldr.driver.run_kickoff_saddle(
                            geo, disp_xyzs, chg, mul, method, basis, orb_restr,
                            fwd_run_path, SCRIPT_STR, prog, OVERWRITE,
                            kickoff_size=KICKOFF_SIZE, kickoff_backward=False,
                            opt_cart=True, **OPT_KWARGS)
                        print('Saving product of kick off from saddle in forward direction')
                        ret = moldr.driver.read_job(job=elstruct.Job.OPTIMIZATION, prefix=fwd_run_path)
                        if ret:
                            inf_obj, inp_str, out_str = ret
                            prog = inf_obj.prog
                            method = inf_obj.method
                            ene = elstruct.reader.energy(prog, method, out_str)
                            geo = elstruct.reader.opt_geometry(prog, out_str)
                            fwd_save_path = dir_afs.direction.dir.path(thy_save_path, [True])
                            print('save path', fwd_save_path)
                            dir_afs.direction.file.geometry_info.write(inf_obj, thy_save_path, [True])
                            dir_afs.direction.file.geometry_input.write(inp_str, thy_save_path, [True])
                            dir_afs.direction.file.geometry.write(geo, thy_save_path, [True])
                            dir_afs.direction.file.energy.write(ene, thy_save_path, [True])

                        print('Kicking off from saddle in backward direction')
                        bwd_run_path = dir_afs.direction.dir.path(thy_run_path, [False])
                        dir_afs.direction.dir.create(thy_run_path, [False])
                        bwd_save_path = dir_afs.direction.dir.path(thy_save_path, [False])
                        dir_afs.direction.dir.create(thy_save_path, [False])
                        moldr.driver.run_kickoff_saddle(
                            geo, disp_xyzs, chg, mul, method, basis,
                            orb_restr, bwd_run_path, SCRIPT_STR, prog,
                            OVERWRITE, kickoff_size=KICKOFF_SIZE,
                            kickoff_backward=True, **OPT_KWARGS)
                        print('Saving product of kick off from saddle in backward direction')
                        ret = moldr.driver.read_job(job=elstruct.Job.OPTIMIZATION, prefix=bwd_run_path)
                        if ret:
                            inf_obj, inp_str, out_str = ret
                            prog = inf_obj.prog
                            method = inf_obj.method
                            ene = elstruct.reader.energy(prog, method, out_str)
                            geo = elstruct.reader.opt_geometry(prog, out_str)
                            bwd_save_path = dir_afs.direction.dir.path(thy_save_path, [False])
                            print('save path', bwd_save_path)
                            dir_afs.direction.file.geometry_info.write(inf_obj, thy_save_path, [False])
                            dir_afs.direction.file.geometry_input.write(inp_str, thy_save_path, [False])
                            dir_afs.direction.file.geometry.write(geo, thy_save_path, [False])
                            dir_afs.direction.file.energy.write(ene, thy_save_path, [False])

if RUN_VDW_QCHEM:
    if NSAMP_VDW_EXPR:
        nsamp = min(NSAMP_VDW_A + NSAMP_VDW_B * NSAMP_VDW_C**ntaudof, NSAMP_VDW_D)
    else:
        nsamp = NSAMP_VDW

    VDW_NAMES_LST = []
    for rct_names, prd_names in zip(RCT_NAMES_LST, PRD_NAMES_LST):
        rct_muls = list(map(MUL_DCT.__getitem__, rct_names))
        prd_muls = list(map(MUL_DCT.__getitem__, prd_names))
        ts_mul = automol.mult.ts.low(rct_muls, prd_muls)
        if len(rct_names) == 2:
            if sorted(rct_names) not in VDW_NAMES_LST:
                VDW_NAMES_LST.append([sorted(rct_names), ts_mul])
        if len(prd_names) == 2:
            if sorted(prd_names) not in VDW_NAMES_LST:
                VDW_NAMES_LST.append([sorted(prd_names), ts_mul])

    for names, ts_mul in VDW_NAMES_LST:
        smis = list(map(SMI_DCT.__getitem__, names))
        ichs = list(map(automol.smiles.inchi, smis))
        chgs = list(map(CHG_DCT.__getitem__, names))
        muls = list(map(MUL_DCT.__getitem__, names))

        method = METHOD
        basis = BASIS
        geos = []
        for ich, chg, mul in zip(ichs, chgs, muls):
            orb_restr = moldr.util.orbital_restriction(mul, RESTRICT_OPEN_SHELL)
            geo = moldr.util.reference_geometry(
                ich, chg, mul, method, basis, orb_restr, SAVE_PREFIX, GEOM_DCT)
            geos.append(geo)
           
        geo1, geo2 = geos
        geo1 = automol.geom.mass_centered(geo1)
        geo2 = automol.geom.mass_centered(geo2)
        for idx in range(nsamp):
            print('Optimizing vdw geometry {}/{}'.format(idx+1,nsamp))
            angs1 = numpy.multiply(
                numpy.random.rand(3), [1*numpy.pi, 2*numpy.pi, 2*numpy.pi])
            angs2 = numpy.multiply(
                numpy.random.rand(3), [1*numpy.pi, 2*numpy.pi, 2*numpy.pi])
            angs12 = numpy.multiply(
                numpy.random.rand(2), [1*numpy.pi, 2*numpy.pi])
            geo1 = automol.geom.euler_rotated(geo1, *angs1)
            geo2 = automol.geom.euler_rotated(geo2, *angs2)
            dist_cutoff = 3.*qcc.conversion_factor('angstrom', 'bohr')

            geo = automol.geom.join(geo1, geo2, dist_cutoff, *angs12)
            print("Species: {}".format('+'.join(names)))
            print('vdw starting geometry')
            print(automol.geom.xyz_string(geo))

    # set up the filesystem
            ich = automol.inchi.recalculate(automol.inchi.join(ichs))
            chg = sum(chgs)
            mul = ts_mul
            orb_restr = moldr.util.orbital_restriction(mul, RESTRICT_OPEN_SHELL)
            spc_run_path = moldr.util.species_path(ich, chg, mul, RUN_PREFIX)
            spc_save_path = moldr.util.species_path(ich, chg, mul, SAVE_PREFIX)
            thy_run_path = moldr.util.theory_path(method, basis, orb_restr, spc_run_path)
            thy_save_path = moldr.util.theory_path(method, basis, orb_restr, spc_save_path)

    # generate reference geometry
    # generate the z-matrix and sampling ranges

            moldr.driver.run_job(
                job=elstruct.Job.OPTIMIZATION,
                geom=geo,
                species_info=ts_info,
                theory_level=RUN_OPT_LEVELS[opt_level_idx],
                prefix=thy_run_path,
                script_str=SCRIPT_STR,
                overwrite=OVERWRITE,
                **OPT_KWARGS,
            )

    # save info for the initial geometry (from inchi or from save directory)
            ret = moldr.driver.read_job(job=elstruct.Job.OPTIMIZATION, prefix=thy_run_path)
            if ret:
                print('Saving reference geometry')
                print(" - Save path: {}".format(thy_save_path))

                inf_obj, inp_str, out_str = ret
                prog = inf_obj.prog
                method = inf_obj.method
                geo = elstruct.reader.opt_geometry(prog, out_str)
                thy_afs = autofile.fs.theory()
                thy_afs.theory.file.geometry.write(geo, spc_save_path, [method, basis, orb_restr])
                ene = elstruct.reader.energy(prog, method, out_str)
                print('ene test in vdw')
                print(ene)
                thy_afs.theory.file.energy.write(ene, spc_save_path, [method, basis, orb_restr])


